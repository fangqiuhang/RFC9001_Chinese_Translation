---
title: "4.1.4. 改变密级"
anchor: "4.1.4_Encryption_Level_Changes"
weight: 414
rank: "h3"
---

As keys at a given encryption level become available to TLS, TLS indicates to QUIC that reading or writing keys at that encryption level are available.

当某个密级的密钥对TLS可用时，TLS会告知QUIC那个密级的读取密钥或写入密钥已经变为可用了。

The availability of new keys is always a result of providing inputs to TLS. TLS only provides new keys after being initialized (by a client) or when provided with new handshake data.

新密钥变为可用这一事件一定是因向TLS提供输入而引发的。TLS只有在（被客户端）初始化后或接收到新握手数据时才会提供新密钥。

However, a TLS implementation could perform some of its processing asynchronously. In particular, the process of validating a certificate can take some time. While waiting for TLS processing to complete, an endpoint SHOULD buffer received packets if they might be processed using keys that are not yet available. These packets can be processed once keys are provided by TLS. An endpoint SHOULD continue to respond to packets that can be processed during this time.

然而，TLS实现可能会异步地进行某些处理过程。尤其是，验证证书的过程可能会花不少时间。当等待TLS处理时，如果终端接收到了需要用尚未可用的密钥来处理的数据包，那么终端{{< req_level SHOULD >}}将它们缓存起来。一旦TLS提供了密钥，这些数据包就能够得到处理。终端{{< req_level SHOULD >}}继续响应此时可以处理的数据包。

After processing inputs, TLS might produce handshake bytes, keys for new encryption levels, or both.

在处理完输入后，TLS可能生成出握手字节、新密级的密钥或两者兼具。

TLS provides QUIC with three items as a new encryption level becomes available:

当新密级可用时，TLS会向QUIC提供以下三份内容：

* A secret

* 一个秘密值

* An Authenticated Encryption with Associated Data (AEAD) function

* 一个带有关联数据的认证加密（AEAD）函数

* A Key Derivation Function (KDF)

* 一个密钥迭代函数（KDF）

These values are based on the values that TLS negotiates and are used by QUIC to generate packet and header protection keys; see Section 5 and Section 5.4.

这些值基于TLS协商出的那些值，以及被QUIC用于生成数据包与头部保护密钥的那些值；详见[第5章]()和[第5.4章]()。

If 0-RTT is possible, it is ready after the client sends a TLS ClientHello message or the server receives that message. After providing a QUIC client with the first handshake bytes, the TLS stack might signal the change to 0-RTT keys. On the server, after receiving handshake bytes that contain a ClientHello message, a TLS server might signal that 0-RTT keys are available.

如果要使用0-RTT，那么0-RTT会在客户端发送了TLS的客户端问候（`ClientHello`）消息或服务器接收到这条消息后就绪。在第一次向QUIC提供握手字节后，TLS栈可能会发送有关0-RTT密钥发生变化的信号。在服务器接收到包含客户端问候消息的握手字节后，TLS服务器可以发送有关0-RTT密钥变为可用的信号。

Although TLS only uses one encryption level at a time, QUIC may use more than one level. For instance, after sending its Finished message (using a CRYPTO frame at the Handshake encryption level) an endpoint can send STREAM data (in 1-RTT encryption). If the Finished message is lost, the endpoint uses the Handshake encryption level to retransmit the lost message. Reordering or loss of packets can mean that QUIC will need to handle packets at multiple encryption levels. During the handshake, this means potentially handling packets at higher and lower encryption levels than the current encryption level used by TLS.

尽管TLS在某一时刻只会使用一个密级，QUIC却可以同时使用不止一个密级。举例来说，终端在发送完已结束消息后（使用的是处于握手密级的**加密帧**），它可以发送**流帧**（使用的是1-RTT加密）。如果已结束消息在传输过程中被丢失了，终端会用握手密级重传丢失的消息。数据包乱序或丢包的存在意味着QUIC可能需要同时处理处于不同密级的数据包。在握手期间，这意味着有可能需要处理位于比TLS正在使用的密级更高或更低的密级的数据包。

In particular, server implementations need to be able to read packets at the Handshake encryption level at the same time as the 0-RTT encryption level. A client could interleave ACK frames that are protected with Handshake keys with 0-RTT data, and the server needs to process those acknowledgments in order to detect lost Handshake packets.

特别是，服务器上的QUIC实现需要有能力同时读取位于握手密级和位于0-RTT密级的数据包。客户端可能使0-RTT数据与受握手密钥保护的**ACK帧**交错传输，而服务器得处理这些确认才能检测出丢包的握手数据包。

QUIC also needs access to keys that might not ordinarily be available to a TLS implementation. For instance, a client might need to acknowledge Handshake packets before it is ready to send CRYPTO frames at that encryption level. TLS therefore needs to provide keys to QUIC before it might produce them for its own use.

QUIC还需要访问对TLS实现来说并不可用的密钥。例如，客户端可能需要在准备好发送握手密级的**加密帧**前确认握手数据包。因此TLS需要在出于自己使用的目的而生成密钥前就向QUIC提供这些密钥。
