---
title: "4.1.3. 发送和接收握手消息"
anchor: "4.1.3_Sending_and_Receiving_Handshake_Messages"
weight: 413
rank: "h3"
---

In order to drive the handshake, TLS depends on being able to send and receive handshake messages. There are two basic functions on this interface: one where QUIC requests handshake messages and one where QUIC provides bytes that comprise handshake messages.

为了进行握手，TLS需要发送和接收握手消息的能力。对于这个接口，有两个基本函数：QUIC从其中一个函数获取握手消息，向另一个函数提供组成握手消息的字节数据。

Before starting the handshake, QUIC provides TLS with the transport parameters (see Section 8.2) that it wishes to carry.

在启动握手前，QUIC向TLS提供它想传递的传输参数（详见[第8.2章]()）。

A QUIC client starts TLS by requesting TLS handshake bytes from TLS. The client acquires handshake bytes before sending its first packet. A QUIC server starts the process by providing TLS with the client's handshake bytes.

QUIC客户端以向TLS获取握手的字节数据的方式启动TLS。客户端在发送首个数据包前获取握手的字节数据。QUIC服务器则以向TLS提供客户端的握手字节数据的方式启动TLS。

At any time, the TLS stack at an endpoint will have a current sending encryption level and a receiving encryption level. TLS encryption levels determine the QUIC packet type and keys that are used for protecting data.

任一终端的TLS栈都始终记录着当前的发送密级和接收密级。TLS密级决定了QUIC数据包类型和用于保护数据的密钥。

Each encryption level is associated with a different sequence of bytes, which is reliably transmitted to the peer in CRYPTO frames. When TLS provides handshake bytes to be sent, they are appended to the handshake bytes for the current encryption level. The encryption level then determines the type of packet that the resulting CRYPTO frame is carried in; see Table 1.

每个密级都关联着各自的一份字节序列，这些字节内容会由**加密帧**可靠地发送给对端。当TLS提供了将要发送的握手字节时，这些字节会被追加到当前密级的握手字节内容后面。该密级决定着最终发送**加密帧**时所用的数据包类型；详见[表1]()。

Four encryption levels are used, producing keys for Initial, 0-RTT, Handshake, and 1-RTT packets. CRYPTO frames are carried in just three of these levels, omitting the 0-RTT level. These four levels correspond to three packet number spaces: Initial and Handshake encrypted packets use their own separate spaces; 0-RTT and 1-RTT packets use the application data packet number space.

四个密级分别为初始数据包、0-RTT数据包、握手数据包和1-RTT数据包生成密钥。其中只有三个密级能被用来传递**加密帧**，不在其中的是0-RTT这个密级。这四个密级对应着三个数据包号空间：受初始密钥和握手密钥加密的数据包分别使用各自的空间；0-RTT数据包和1-RTT数据包使用应用数据数据包号空间。

QUIC takes the unprotected content of TLS handshake records as the content of CRYPTO frames. TLS record protection is not used by QUIC. QUIC assembles CRYPTO frames into QUIC packets, which are protected using QUIC packet protection.

QUIC使用未受保护的TLS握手记录的内容作为**加密帧**的内容。QUIC不使用TLS的记录保护。QUIC将**加密帧**组装进具有QUIC数据包保护的QUIC数据包。

QUIC CRYPTO frames only carry TLS handshake messages. TLS alerts are turned into QUIC CONNECTION_CLOSE error codes; see Section 4.8. TLS application data and other content types cannot be carried by QUIC at any encryption level; it is an error if they are received from the TLS stack.

QUIC**加密帧**仅传递TLS握手消息。TLS警告被转换为QUIC**连接关闭帧**的错误码；详见[第4.8章]()。TLS应用数据和其他内容类型不能由QUIC以任何密级传递；不应该从TLS栈接收到它们，否则这是一种错误。

When an endpoint receives a QUIC packet containing a CRYPTO frame from the network, it proceeds as follows:

当终端从网络接收到了一个包含**加密帧**的QUIC数据包时，它应该这样处理：

* If the packet uses the current TLS receiving encryption level, sequence the data into the input flow as usual. As with STREAM frames, the offset is used to find the proper location in the data sequence. If the result of this process is that new data is available, then it is delivered to TLS in order.

* 如果数据包使用了当前的TLS接收密级，那么数据会被正常地按顺序置入输入流。和**流帧**一样，要使用偏移值来在数据序列中找到正确的置入位置。如果完成该过程后出现了新的可用数据，那么新数据会被有序地交付给TLS。

* If the packet is from a previously installed encryption level, it MUST NOT contain data that extends past the end of previously received data in that flow. Implementations MUST treat any violations of this requirement as a connection error of type PROTOCOL_VIOLATION.

* 如果数据包来自之前使用过的密级，那么它包含的数据{{< req_level MUST_NOT >}}扩展那个密级的数据流末尾。QUIC实现{{< req_level MUST >}}将任何违反这项要求的情况视作类型为`PROTOCOL_VIOLATION`（协议违反）的连接错误。

* If the packet is from a new encryption level, it is saved for later processing by TLS. Once TLS moves to receiving from this encryption level, saved data can be provided to TLS. When TLS provides keys for a higher encryption level, if there is data from a previous encryption level that TLS has not consumed, this MUST be treated as a connection error of type PROTOCOL_VIOLATION.

* 如果数据包来自新的密级，那么它会被保存起来，用于将来给TLS处理。一旦TLS改用此密级接收数据，暂存着的数据就可以被交给TLS。当TLS为更高的密级提供密钥时，如果还有来自之前的密级但是还未被TLS处理的数据，那么{{< req_level MUST >}}将该情况视作类型为`PROTOCOL_VIOLATION`的连接错误。

Each time that TLS is provided with new data, new handshake bytes are requested from TLS. TLS might not provide any bytes if the handshake messages it has received are incomplete or it has no data to send.

每次将新数据交给TLS时，都会向TLS获取新的握手字节。如果TLS接收到的握手消息不完整或它没有数据需要发送，那么它可能不会提供任何字节数据。

The content of CRYPTO frames might either be processed incrementally by TLS or buffered until complete messages or flights are available. TLS is responsible for buffering handshake bytes that have arrived in order. QUIC is responsible for buffering handshake bytes that arrive out of order or for encryption levels that are not yet ready. QUIC does not provide any means of flow control for CRYPTO frames; see Section 7.5 of [QUIC-TRANSPORT].

**加密帧**的内容可能会被TLS增量处理，或被缓存起来直到有完整的可用消息。TLS负责缓存按序到达的握手字节数据。QUIC负责缓存未按序到达或属于尚未可用的密级的握手字节。QUIC不会为**加密帧**提供任何流量控制的方法；详见《[QUIC传输]()》的[第7.5章]()。

Once the TLS handshake is complete, this is indicated to QUIC along with any final handshake bytes that TLS needs to send. At this stage, the transport parameters that the peer advertised during the handshake are authenticated; see Section 8.2.

一旦TLS握手完成，这一事件就会随着TLS要发送的最后的握手字节一起被告知给QUIC。在这个阶段，握手期间对端宣告的传输参数会被验证；详见[第8.2章]()。

Once the handshake is complete, TLS becomes passive. TLS can still receive data from its peer and respond in kind, but it will not need to send more data unless specifically requested -- either by an application or QUIC. One reason to send data is that the server might wish to provide additional or updated session tickets to a client.

一旦握手完成，TLS就变得被动起来。TLS仍然可以从对端接收数据并作出响应，但它没有必要发送更多数据，除非被应用或QUIC专门提出要发送数据的请求。发送数据的可能原因之一是服务器可能想要向客户端新增或更新会话票据。

When the handshake is complete, QUIC only needs to provide TLS with any data that arrives in CRYPTO streams. In the same manner that is used during the handshake, new data is requested from TLS after providing received data.

当握手完成后，QUIC只需要向TLS提供以**加密帧**的形式到达的数据。和握手期间的行为一样，处理完接收到的数据后QUIC会向TLS获取新数据。
